# Explanation of `.claude/commands/revise-claude-md.md`

## What This File Does

This document is an instruction manual for a command called `/revise-claude-md` that helps the AI assistant learn from its experiences and document those lessons for future sessions. Think of it like a teacher writing notes in a lesson plan after class, recording what worked well, what students struggled with, and what tips would help the next teacher who teaches this material. After the AI finishes helping you with a task, this command guides it to reflect on what it learned about your specific codebase - useful commands it discovered, coding patterns it should follow, quirks or gotchas it encountered - and then updates a special documentation file called `CLAUDE.md` so that future AI sessions can benefit from this knowledge. It's essentially a "continuous improvement" process that makes each session smarter than the last.

## Key Components

**Purpose Statement**: The opening line explains the core function - "Update CLAUDE.md with learnings from this session." It also specifies which tools are allowed (Read, Edit, Glob), meaning the AI can read files, edit files, and search for file patterns, but not do anything more complex or risky.

**Five-Step Process**: The command breaks down the learning documentation process into five clear phases:

**Step 1 - Reflect**: This is the introspection phase where the AI reviews what just happened in the current session. It asks specific reflective questions:
- What commands were used or discovered that were helpful?
- What coding style patterns did we follow (like naming conventions or formatting)?
- What testing approaches worked well?
- What environment quirks or configuration oddities came up?
- What warnings or "gotchas" (unexpected problems) did we encounter?

Think of this like a pilot filling out a post-flight checklist, noting anything unusual about the aircraft or weather conditions.

**Step 2 - Find CLAUDE.md Files**: This step involves searching the codebase to locate where documentation should be stored. It runs a search command to find files named `CLAUDE.md` or `.claude.local.md`, then explains the difference:
- `CLAUDE.md` - Team-shared documentation that gets saved in version control (everyone on the team sees these notes)
- `.claude.local.md` - Personal notes that stay on your computer only (private learning that doesn't get shared)

This is like deciding whether to write something in the shared team handbook or in your personal notebook.

**Step 3 - Draft Additions**: This section provides guidelines for writing the actual documentation updates. The key principle is **"Keep it concise"** because CLAUDE.md gets loaded into the AI's memory every session, so brevity matters - long-winded explanations waste valuable memory space. The recommended format is simple: `<command or pattern>` - `<brief description>`. 

It also lists what to avoid:
- Verbose (wordy) explanations
- Obvious information everyone already knows
- One-off fixes that won't happen again

Think of this like writing bullet points on a cheat sheet rather than writing full paragraphs in an essay.

**Step 4 - Show Proposed Changes**: Before making any changes, the AI must present what it plans to add in a structured format showing:
- Which file will be updated (e.g., `./CLAUDE.md`)
- **Why** the addition is valuable (one-line reason)
- The actual addition in a "diff" format (showing what will be added with a `+` symbol)

This is like a contractor showing you a proposal before starting work - you see exactly what they plan to do before they do it.

**Step 5 - Apply with Approval**: The final step emphasizes that the AI must ask permission before making changes. It can only edit files after the user approves the proposed additions. This is a safety mechanism ensuring nothing gets changed without your consent.

## How It Works

**The Reflection Process**: After completing a task with you, when you run `/revise-claude-md`, the AI pauses to reflect on the session. It mentally reviews what happened - Did it have to search for configuration settings? Did it discover a specific command that worked well? Did it encounter an unexpected error that might happen again? Did it follow certain code formatting patterns that should be documented?

**The Search Phase**: Once the AI identifies valuable lessons, it searches your project to find the appropriate documentation files. It looks for `CLAUDE.md` (the shared team documentation) and `.claude.local.md` (your personal notes). If multiple files exist (like a main project CLAUDE.md and subdirectory CLAUDE.md files), it decides which one is most appropriate for each learning.

**The Drafting Phase**: For each lesson learned, the AI drafts a concise, one-line addition. For example:
- Instead of writing: "When running tests, you need to make sure the test database is initialized first because the system expects certain tables to exist, otherwise you'll get errors"
- It writes: `pytest tests/` - `Run tests (requires test DB initialization first)`

The goal is maximum information density with minimum words.

**The Proposal Phase**: Before changing anything, the AI shows you exactly what it wants to add and explains why. For example:

```
### Update: ./CLAUDE.md

**Why:** Document required test database setup to prevent future test failures

```diff
+ `pytest tests/` - Run tests (requires test DB initialization first)
```
```

This gives you a clear preview of the proposed change in an easy-to-read format showing the file, the reason, and the addition.

**The Approval and Application Phase**: The AI then asks "Should I apply these changes?" and waits for your response. Only after you say "yes" (or approve specific changes) does it actually edit the documentation files. This prevents unwanted modifications and gives you full control.

**The Cumulative Learning Effect**: Each time this command runs, `CLAUDE.md` gets incrementally better. After several sessions, it might contain valuable shortcuts like:
- `npm run dev -- --port 3001` - Dev server (port 3000 often conflicts)
- Use `snake_case` for Python files, `camelCase` for JavaScript
- Redis must be running before starting queue processor
- `.env.local` overrides `.env` (keep secrets in .env.local)

Future AI sessions read this file at startup and immediately know these project-specific details without rediscovering them.

## Important Things to Know

**This is About Continuous Improvement**: The whole purpose of this command is to make working with the AI progressively better over time. Each session teaches the AI something new about your specific project, and those lessons get documented so they're not forgotten. It's like building up institutional knowledge rather than starting from scratch every time.

**It Focuses on Project-Specific Knowledge**: The command isn't documenting general programming knowledge (the AI already knows how to write Python or JavaScript). Instead, it captures quirks and specifics about YOUR codebase - like "the test database needs special setup" or "this project uses port 7786 instead of the default" or "configuration files must be named exactly `config.local.json`." These are things that wouldn't be obvious from reading general documentation.

**Brevity is Critical**: The document repeatedly emphasizes keeping additions concise - "one line per concept," "keep it brief," "avoid verbose explanations." This is because `CLAUDE.md` gets loaded into the AI's working memory at the start of every session, and that memory has limits. Long, wordy documentation wastes precious space that could be used for understanding your code. Think of it like fitting instructions on an index card rather than writing a manual.

**Two Types of Documentation**: The distinction between `CLAUDE.md` (shared with team) and `.claude.local.md` (personal) is important. Shared documentation should contain information useful to anyone working on the project. Personal documentation might contain your specific preferences or workflow notes that wouldn't help others. For example:
- Shared: "Tests require Redis running on port 6379"
- Personal: "I prefer running tests with verbose output using `-v` flag"

**User Approval is Required**: This command never makes changes without permission. It always shows you what it plans to add and waits for your approval. This safety mechanism prevents the AI from accidentally documenting incorrect information or making unwanted changes to your project files.

**It's Reflective, Not Automatic**: The AI doesn't automatically capture everything - it has to thoughtfully reflect on what was actually valuable versus what was routine or obvious. Good documentation updates capture genuinely useful, non-obvious information that will help in future sessions. Bad updates would clutter the file with obvious things like "use `git commit` to commit code" (everyone knows this already).

**The Learning Compounds Over Time**: The first time you run this command on a new project, there might be many additions because everything is new. As the project matures and `CLAUDE.md` gets more complete, each session might only add one or two highly specific learnings. Eventually, you have a rich knowledge base that makes the AI immediately productive in your codebase without needing to rediscover project quirks.

**Examples of Good vs. Bad Additions**:

Good (concise, specific, valuable):
- `Relay server MUST run on port 7786` - Critical port requirement
- `Use dark mode for all HTML in /opt/clawd/projects/.preview/` - User preference
- `watcher.py requires heartbeat every 30s or restarts` - Non-obvious behavior

Bad (too verbose, obvious, or one-off):
- `You can use Python to write code in this project` - Too obvious
- `I fixed a typo in line 47 of server.py where 'teh' should be 'the'` - One-off fix, not useful future knowledge
- `When deploying to production, you need to ensure all dependencies are installed and the configuration is set up properly and the database is migrated and...` - Too verbose, should be multiple concise points

**Limited Tool Access**: The command is restricted to only using Read, Edit, and Glob tools - meaning it can read files, edit files, and search for file patterns. It cannot run bash commands, make git commits, or do anything that might have broader system impacts. This restriction ensures the command stays focused on its documentation purpose and doesn't accidentally trigger unintended side effects.