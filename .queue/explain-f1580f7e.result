# Simple Explanation: Walter Mobile App Security & Architecture Guide

## 1. What This File Does

This document is a comprehensive security blueprint that explains how the Walter voice assistant mobile app is built to be completely secure by keeping all passwords, secret keys, and sensitive credentials locked safely on company servers—never on users' phones. It's like an instruction manual showing developers exactly how to build a mobile app where losing your phone wouldn't expose any company secrets, because the phone only holds temporary "guest passes" that expire, not the master keys to the building.

---

## 2. Key Components

### **A. Security Principles Table (Section 1)**

Six core security rules that govern how the app operates:

1. **No secrets on device**: Like keeping the vault combination at the bank headquarters, never written on deposit slips—all passwords and API keys stay on servers
2. **Token-based auth**: Instead of carrying your passport everywhere, you get temporary visitor badges (JWT tokens) that expire
3. **Microsoft SSO**: Users sign in with their work Microsoft account instead of creating yet another password
4. **Encrypted transport**: All data travels in locked, armored vehicles (HTTPS/WSS encryption) instead of postcards anyone can read
5. **Session isolation**: Each user's session is tracked separately in a secure database (Redis), like individual safety deposit boxes
6. **Company isolation**: Server automatically ensures you can only see your own company's insurance data, never competitors'

### **B. Authentication Flow Diagram (Section 2.1)**

A detailed ASCII art flowchart showing the 10-step login dance between three parties:

1. **Mobile App** (the phone app built with Capacitor technology)
2. **Walter Backend** (the company's servers running Express/Node)
3. **Microsoft Entra ID** (Microsoft's identity verification service)

**The Login Story:**
- User taps "Sign in with Microsoft"
- App asks Walter's server where to go
- Server directs to Microsoft's official login page
- User enters Microsoft password (maybe with security code)
- Microsoft verifies identity and sends back proof
- Walter's server checks if user exists in its database (creates account if new)
- Walter creates two special tokens for this phone
- App stores tokens in phone's most secure vault (iOS Keychain or Android Keystore)

### **C. Token Lifecycle Table (Section 2.2)**

Explains the three types of digital "keys" used in the system:

1. **Access Token** (24-hour pass):
   - Like a hotel keycard good for one day
   - Proves who you are when making requests
   - Stored in phone's secure vault
   
2. **Refresh Token** (7-day voucher):
   - Like a week-long pass renewal voucher
   - Gets you new 24-hour passes without re-logging in
   - Also stored in phone's secure vault

3. **Microsoft ID Token**:
   - Server-side only, never sent to phone
   - Used once to verify identity, then discarded
   - Like showing your driver's license to hotel staff who verify it but don't photocopy it

### **D. Token Refresh Flow Diagram (Section 2.3)**

Shows how the app automatically gets fresh access tokens without bothering the user:

1. Before access token expires (24 hours), app sends refresh token to Walter's server
2. Server verifies: Is the refresh token valid? Is the session still active? Is user still authorized?
3. Server issues brand new access token and refresh token
4. App stores new tokens securely
5. User never notices—stays logged in seamlessly

### **E. What Mobile App Receives (Section 2.4)**

A JSON code example showing **exactly** what data the phone app gets after login:

```json
{
  "accessToken": "eyJ...",
  "refreshToken": "eyJ...",
  "user": {
    "id": "uuid",
    "email": "brett@company.com",
    "firstName": "Brett",
    "role": "broker",
    "companyId": "uuid"
  }
}
```

**Critical point**: "**No API keys, no Azure credentials, no database URLs** — ever."

### **F. Voice Architecture Diagrams (Section 3)**

Two different setups for handling voice conversations:

**Development Mode (Section 3.1):**
- Simple direct connection: Mobile App ↔ Walter Backend ↔ Azure OpenAI
- Like a three-way phone call
- Good for testing and small deployments

**Production Mode (Section 3.2):**
- Scalable infrastructure: Mobile App ↔ Azure Web PubSub ↔ Walter Backend ↔ Azure OpenAI
- Azure Web PubSub acts like a telephone switchboard handling thousands of simultaneous calls
- Auto-scales for many users, better reliability, lower latency

**Audio Flow (Section 3.3):**
1. User speaks into microphone
2. Phone converts speech to digital audio (PCM16 format at 24kHz)
3. Audio chunks sent through WebSocket to backend
4. Backend forwards to Azure OpenAI's AI voice system
5. AI responds with audio
6. Audio travels back through the chain
7. Phone plays AI voice through speaker

### **G. Mobile App Configuration (Section 4.1)**

Example configuration file showing the **only** settings needed in the mobile app:

```typescript
export const config = {
  API_BASE_URL: 'https://walter-api.yourcompany.com',
  MSAL_CLIENT_ID: 'xxx-xxx-xxx',
  MSAL_AUTHORITY: 'https://login.microsoftonline.com/TENANT_ID',
  // ... more PUBLIC settings
};
```

**Key point**: These are all public, non-secret values. The document emphasizes that `CLIENT_ID` is **not** a secret—it's like a store's address, publicly visible but harmless alone.

### **H. Secrets That Stay on Server (Section 4.2)**

A comprehensive table listing 10 secrets that **never** touch the mobile app:

- Azure client secrets
- JWT signing keys
- OpenAI API keys
- Database passwords
- Redis connection strings
- Session encryption keys
- Service passwords

**Analogy**: It's like how ATM cards work—your card has your account number (public), but the bank vault combination stays at the bank headquarters.

### **I. Secure Token Storage Code (Section 4.3)**

TypeScript code examples showing how tokens are stored using Capacitor Secure Storage:

```typescript
// Store after login
await SecureStoragePlugin.set({
  key: 'walter_access_token',
  value: accessToken
});

// Retrieve for API calls
const { value: token } = await SecureStoragePlugin.get({
  key: 'walter_access_token'
});
```

**Platform Security:**
- **iOS**: Uses iOS Keychain (hardware-encrypted, can require Face ID/Touch ID)
- **Android**: Uses Android Keystore (hardware-backed encryption)
- **On logout**: Tokens deleted from phone AND server session destroyed

### **J. API Interaction Patterns (Section 5)**

Code examples showing how the mobile app talks to the backend:

1. **Every request includes access token** in the `Authorization: Bearer` header
2. **Automatic token refresh**: If server returns 401 (unauthorized), app automatically uses refresh token to get new access token and retries
3. **Graceful logout**: If refresh also fails, app logs user out and shows login screen

**API Endpoints Table (Section 5.2):**
Lists all the server URLs the mobile app connects to:
- `/api/auth/microsoft` - Start Microsoft login
- `/api/auth/refresh` - Get fresh tokens
- `/api/voice/negotiate` - Request voice session
- `/api/quotes` - Get insurance quotes
- ... and more

### **K. Production Deployment Checklist (Section 6)**

Three comprehensive checklists for launching the app:

**Backend Configuration (6.1):**
- Environment variables that need to be set on the server
- CORS settings to allow mobile app connections
- Security settings for production

**Azure Configuration (6.2):**
- Steps to configure Microsoft Entra ID (Azure AD) app registration
- Enable mobile platform support
- Set redirect URIs
- Grant necessary permissions

**Security Hardening (6.3):**
- 14-item checklist including:
  - ✓ Force HTTPS/WSS encryption
  - ✓ Use strong random JWT secrets (64+ characters)
  - ✓ Enable rate limiting on login endpoints
  - ✓ Configure database SSL
  - ✓ Rotate API keys regularly
  - ✓ Consider biometric authentication
  - ✓ Detect suspicious activity

### **L. Technology Stack Table (Section 7)**

Lists all the technologies used to build the mobile app:

| Technology | Purpose |
|---|---|
| Capacitor + React/TypeScript | Cross-platform framework (one codebase for iOS + Android) |
| @azure/msal-react-native | Microsoft login integration |
| capacitor-secure-storage-plugin | Secure token storage |
| WebAudio API | Voice capture and playback |
| WebSocket API | Real-time voice streaming |
| Tailwind CSS | User interface styling |

---

## 3. How It Works

### **The Complete Security Model:**

Think of the Walter mobile app security like a **modern office building access system**:

**Old Insecure Way (What Walter DOESN'T Do):**
- Give everyone a master key to copy (storing passwords on phones)
- Write vault combinations on sticky notes (storing API keys in app code)
- Anyone who steals a key can access everything forever

**Walter's Secure Way:**

**Phase 1: Getting In (Authentication)**
1. You show your **company badge** (Microsoft work account) at the front desk
2. Security guard calls Microsoft to verify you're really an employee
3. Microsoft confirms: "Yes, that's Brett from Artemis Insurance"
4. Walter's system checks: "Does Brett have an account? No? Create one automatically."
5. You receive **two digital keycards**:
   - **Yellow card** (access token): Good for 24 hours, opens all doors
   - **Blue voucher** (refresh token): Good for 7 days, can get you new yellow cards

**Phase 2: Daily Use (Authorization)**
1. Every time you want to access something (view quotes, use voice AI), you **show your yellow keycard**
2. Server checks: "Is this card valid? Is it expired? Does Brett's role allow this action?"
3. If valid, access granted
4. If expired (24 hours passed), app automatically uses blue voucher to get fresh yellow card
5. User never notices—stays seamlessly logged in

**Phase 3: Voice Conversations**
1. Request a **voice session ticket** from Walter's server
2. Server creates temporary WebSocket connection URL (good for 30 minutes)
3. Open live audio channel (like a phone call to the AI)
4. Speak → Phone captures audio → Sends to server in 200ms chunks
5. Server forwards to Azure OpenAI's voice AI
6. AI responds with voice → Server forwards back → Phone plays through speaker
7. User sees live transcript of entire conversation on screen

**Phase 4: When Things Go Wrong**
- **Lost phone**: Thief only has tokens that expire in 24 hours max, can't access any secrets
- **Stolen token**: Can only access what that user's role permits, expires quickly
- **Suspicious activity**: Server can invalidate session immediately, forcing re-login
- **Token expires**: App automatically refreshes in background, user doesn't notice
- **Refresh fails**: User sees login screen, must re-authenticate with Microsoft

### **Why This Architecture Matters:**

**The Zero-Trust Principle:**
- Phone app is treated as **untrusted** device
- All secrets stay on **trusted** servers in secure data centers
- Even if entire phone is compromised (jailbroken, malware-infected), attacker only gets:
  - Temporary tokens that expire
  - User's own data (not other users' data)
  - No ability to impersonate the server
  - No access to database, AI services, or encryption keys

**Defense in Depth:**
Multiple layers of security, like castle walls:
1. **Outer wall**: HTTPS/WSS encryption (data can't be intercepted)
2. **Moat**: Token expiration (stolen credentials become useless quickly)
3. **Inner gate**: Server-side validation (every request verified)
4. **Throne room**: Secrets locked on server (never exposed to phones)
5. **Guards**: Session tracking (suspicious activity detected)
6. **Drawbridge**: Company isolation (users can't see competitors' data)

---

## 4. Important Things to Know

### **The "No Secrets on Device" Philosophy:**

This is the **central security principle** that governs everything. Here's why it matters:

**If secrets were on the phone:**
- **Decompiling the app** would expose API keys (hackers can reverse-engineer apps)
- **Rooted/jailbroken phones** could extract credentials from memory
- **Malware** could steal keys and impersonate the app
- **Lost devices** become permanent security breaches
- **Rotating credentials** would require updating every installed app

**With Walter's architecture:**
- **Decompile the app**: Only find public configuration (harmless)
- **Root the phone**: Only get tokens that expire in 24 hours
- **Malware steals tokens**: Limited damage, expires quickly, can be revoked
- **Lose phone**: Report to admin, they invalidate session server-side instantly
- **Rotate API keys**: Change once on server, affects all apps immediately

### **Token Expiration Strategy:**

**Why 24 hours for access tokens?**
- Short enough to limit damage if stolen
- Long enough that users aren't constantly logging in
- Auto-refresh happens in background invisibly

**Why 7 days for refresh tokens?**
- Weekly re-authentication is reasonable for business apps
- Balances security (not infinite) with UX (not daily hassles)
- If user doesn't use app for a week, they should re-authenticate

**Why separate tokens instead of one long-lived token?**
- Access tokens are sent with **every API request** (high exposure risk)
- Refresh tokens only sent **once every 24 hours** (low exposure risk)
- If access token stolen, attacker has max 24 hours (probably less)
- Refresh token theft is much less likely due to infrequent use

### **Microsoft SSO Benefits:**

**For users:**
- One less password to remember
- If they already logged into Microsoft today, one-click sign-in (single sign-on)
- Multi-factor authentication managed by Microsoft (SMS codes, authenticator apps)

**For companies:**
- Central user management (add/remove employees in one place)
- Disable ex-employee's Microsoft account → automatically locked out of Walter
- Enforce company security policies (password complexity, MFA requirements)
- Audit logs of all login activity through Microsoft
- Leverage Microsoft's billion-dollar security infrastructure

**For developers:**
- Don't build custom password storage (huge liability)
- Don't implement password reset flows
- Don't handle MFA logic
- Automatic account provisioning (user signs in → account created automatically)

### **Production vs. Development Voice Architecture:**

**Development Mode (Direct WebSocket):**
- **Pros**: Simple to set up, easy to debug, low cost for small scale
- **Cons**: Single server bottleneck, limited concurrent users, no geographic distribution
- **Use when**: Building prototype, testing features, fewer than 100 users

**Production Mode (Azure Web PubSub):**
- **Pros**: Auto-scales to thousands of users, global CDN-like distribution, automatic reconnection
- **Cons**: More complex setup, additional Azure service cost
- **Use when**: Launching to customers, expecting growth, need reliability guarantees

**Analogy**: Direct WebSocket is like a small restaurant with one chef. Web PubSub is like a franchise with kitchens worldwide—handles rush hour, never runs out of capacity.

### **Security Hardening Checklist Importance:**

The 14-item checklist in Section 6.3 isn't just suggestions—it's **critical production requirements**:

- **HTTPS enforced**: Without this, attackers can intercept tokens mid-flight
- **Strong JWT secret**: Weak secrets allow attackers to forge tokens
- **Rate limiting**: Prevents brute-force password guessing
- **Redis authentication**: Prevents unauthorized session access
- **Database SSL**: Protects data traveling to/from database
- **Certificate pinning**: Advanced protection against man-in-the-middle attacks
- **Biometric unlock**: Adds extra layer (Face ID/Touch ID to open app)

**Each unchecked item is a potential vulnerability** that sophisticated attackers could exploit.

### **What Happens When User Logs Out:**

1. **Mobile app side:**
   - Deletes access token from secure storage
   - Deletes refresh token from secure storage
   - Clears user data from memory
   - Shows login screen

2. **Server side:**
   - Destroys Redis session (invalidates all tokens for that session)
   - Even if attacker somehow still has old tokens, server rejects them
   - Audit log records logout event with timestamp

**Complete cleanup ensures no residual access.**

### **Cross-Platform Strategy:**

**Capacitor framework** allows writing code **once** that runs on both iOS and Android:

- **Shared code**: 90%+ of app logic is TypeScript/React (works on both platforms)
- **Platform-specific**: Secure storage calls iOS Keychain on iPhone, Android Keystore on Android
- **Native plugins**: Audio capture, Microsoft SSO, WebSocket all use native platform APIs
- **Result**: One development team can maintain both apps, faster feature delivery

### **The JSON Response (Section 2.4):**

When user logs in, the mobile app receives this JSON response. Let's decode what each field means:

```json
{
  "accessToken": "eyJ..." // The 24-hour pass (JWT format - long encrypted string)
  "refreshToken": "eyJ..." // The 7-day voucher (also JWT format)
  "user": {
    "id": "uuid", // Walter's internal ID for this user
    "email": "brett@company.com", // From Microsoft account
    "firstName": "Brett", // Extracted from Microsoft profile
    "lastName": "K",
    "role": "broker", // Walter's permission level (broker, admin, etc.)
    "companyId": "uuid" // Which insurance broker company Brett works for
  }
}
```

**What's NOT included:**
- No Microsoft password
- No API keys
- No database credentials
- No Azure service keys
- Just identity info and temporary access tokens

### **PKCE (Mentioned in Section 4.1):**

The document mentions **PKCE** (Proof Key for Code Exchange, pronounced "pixy"):

**Why it exists:**
- Traditional OAuth was designed for web servers with secret keys
- Mobile apps can't securely store secrets (anyone can decompile the app)
- PKCE allows secure OAuth without requiring a client secret on the mobile app

**How it works (simplified):**
1. App generates random code verifier (like a one-time password)
2. App creates challenge (scrambled version of verifier)
3. App sends challenge to Microsoft during login
4. Microsoft returns authorization code
5. App sends code + original verifier to Walter backend
6. Backend verifies: Does the verifier match the challenge? If yes, proceed.
7. Even if attacker intercepts the authorization code, they don't have the verifier, so it's useless

**Result**: Secure authentication without storing secrets on the phone.

---

## In Summary

This document is a **comprehensive security blueprint** for building a mobile voice assistant app where:

- **Zero secrets stored on phones** (all credentials stay server-side)
- **Microsoft enterprise SSO** for login (no custom password management)
- **Short-lived tokens** that expire and refresh automatically
- **Hardware-encrypted storage** (iOS Keychain / Android Keystore)
- **Scalable voice architecture** (direct WebSocket for dev, Azure Web PubSub for production)
- **Defense-in-depth security** (multiple layers of protection)
- **Complete deployment checklists** (nothing left to chance)

It's designed so that even if an attacker:
- Steals a phone
- Decompiles the app
- Roots/jailbreaks the device
- Intercepts network traffic

They **cannot** access company secrets, impersonate the server, or cause lasting damage—because the phone only holds temporary, expiring credentials, never the keys to the kingdom.

Think of it like modern hotel security: Your keycard works for your stay, but the master key system stays locked in the manager's office safe, not printed on every guest card.