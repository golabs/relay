# Simple Explanation: Walter Mobile App Security & Architecture Guide

## 1. What This File Does

This document is a comprehensive technical blueprint that explains how to build a secure mobile app for Walter (a voice AI assistant for insurance) where **absolutely no passwords, secret keys, or sensitive credentials are ever stored on the user's phone**. It's like a master instruction manual for developers that shows exactly how to create a mobile app that keeps all the important secrets locked safely on company servers while still allowing users to sign in easily with their Microsoft work accounts and have secure voice conversations with the AI assistant.

---

## 2. Key Components

### **Section 1: Security Principles Table**

This is the foundation—six core security rules that govern the entire system:

1. **No secrets on device**: All passwords, database keys, and API credentials stay on secure servers—phones never get access to them
2. **Token-based auth**: Instead of storing passwords, the app uses temporary digital "tickets" (JWT tokens) that expire after 24 hours
3. **Microsoft SSO**: Users sign in with their existing Microsoft work account—no new passwords to create or store
4. **Encrypted transport**: All data traveling between phone and servers is encrypted (like sending mail in locked safes instead of postcards)
5. **Session isolation**: Each user's session is tracked separately in a secure database (Redis)
6. **Company isolation**: Users can only see data from their own insurance broker company—automatic security filters prevent crossing boundaries

**Analogy**: These are like the building codes for constructing a high-security office building—non-negotiable rules that ensure safety no matter what.

---

### **Section 2: Authentication Flow (The Login Process)**

#### **2.1 Microsoft SSO Login Diagram**

A detailed ASCII art flowchart showing the **10-step dance** between three participants:
- **Mobile App** (user's phone)
- **Walter Backend** (company servers)
- **Microsoft Entra ID** (Microsoft's identity verification service)

**The 10-step journey:**

1. **User taps "Sign in with Microsoft"** in the Walter app
2. **Walter's server sends the app to Microsoft's login page**
3. **App opens Microsoft's official login in a secure browser window**
4. **User enters their work email and password** into Microsoft's form (not Walter's!)
5. **Microsoft verifies identity** (may ask for security code if multi-factor auth is enabled)
6. **Microsoft sends an authorization code back** to Walter's server
7. **Walter's server exchanges that code with Microsoft** for official identity tokens
8. **Microsoft confirms**: "Yes, this is Brett K from your company"
9. **Walter checks its database**—if Brett exists, load profile; if not, create account automatically
10. **Walter creates two tokens** for Brett's phone:
    - **Access token** (24-hour pass)
    - **Refresh token** (7-day renewal voucher)
11. **Walter sends both tokens to the mobile app**
12. **App stores tokens in iPhone Keychain or Android Keystore** (hardware-encrypted vault)
13. **Brett is now logged in** and can use Walter

**Analogy**: It's like checking into a hotel—you show your driver's license (Microsoft account) at the front desk, the clerk verifies it's real, then gives you a room keycard (access token) good for today and a voucher (refresh token) that lets you get new keycards for up to a week without showing ID again.

#### **2.2 Token Lifecycle Table**

Explains the three types of digital "keys" and how long they last:

- **Access Token**: 24-hour pass, proves who you are for API requests, stored in Keychain/Keystore
- **Refresh Token**: 7-day renewal voucher, lets you get new access tokens without re-logging in, stored in Keychain/Keystore
- **Microsoft ID Token**: Server-side only (never sent to phone), used once to create your account then discarded

**Analogy**: Access token = daily amusement park wristband; Refresh token = season pass voucher you can exchange for new wristbands; Microsoft ID token = the park's internal verification system that guests never see.

#### **2.3 Token Refresh Flow**

A simple diagram showing how the app automatically renews expired access tokens:

1. **App detects 24-hour access token expired**
2. **Sends 7-day refresh token to Walter's server** (`POST /api/auth/refresh`)
3. **Server verifies**: Checks JWT signature, validates session in Redis, confirms user is active
4. **Server returns fresh tokens**: New access token + new refresh token (both rotate—old ones become invalid)
5. **App stores new tokens** in secure storage

**Analogy**: Like renewing your library card before it expires—you show your membership voucher, librarian verifies you're in good standing, issues fresh card, and your old card stops working.

#### **2.4 What the Mobile App Receives**

A JSON code sample showing **exactly** what data the phone gets after successful login:

```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIs...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIs...",
  "user": {
    "id": "uuid",
    "email": "brett@company.com",
    "firstName": "Brett",
    "lastName": "K",
    "role": "broker",
    "companyId": "uuid"
  }
}
```

**Critical statement in bold**: "**No API keys, no Azure credentials, no database URLs** — ever."

---

### **Section 3: Voice Conversation Architecture**

#### **3.1 Development Mode (Direct WebSocket)**

A 3-participant diagram showing the simple voice connection for development/testing:

- **Mobile App** captures audio from microphone
- **Walter Backend** acts as proxy/middleman
- **Azure OpenAI** provides the AI brain

**Connection**: `wss://walter-backend/api/voice/ws?token={ACCESS_TOKEN}`

**Security measures:**
1. JWT token validated before allowing WebSocket upgrade
2. One active voice session per user (can't have multiple simultaneous calls)
3. Sessions auto-expire after 30 minutes of inactivity
4. All Azure API credentials handled server-side only

**Analogy**: Like a three-way phone call where Walter's server is the operator connecting you to the AI, checking your ID before connecting you.

#### **3.2 Production Mode (Azure Web PubSub)**

A more advanced 4-participant architecture for handling thousands of users simultaneously:

- **Mobile App** sends audio
- **Azure Web PubSub Service** (enterprise message routing system)
- **Walter Backend** (still the proxy)
- **Azure OpenAI** (AI brain)

**Connection flow:**
1. App calls `/api/voice/negotiate` with Bearer token
2. Backend validates token, creates temporary WebSocket URL (short-lived, scoped to this session)
3. App connects to Web PubSub—messages automatically routed to backend
4. Backend proxies audio to/from Azure OpenAI

**Why Web PubSub for production:**
- **Auto-scaling** to thousands of concurrent voice sessions
- **Geographic distribution** (servers closer to users = lower latency)
- **Connection resilience** with automatic reconnection if network drops
- **Reduced backend load** (Web PubSub handles connections, not Walter's servers)

**Analogy**: Development mode is like a small restaurant where the owner cooks, serves, and handles reservations. Production mode is like a nationwide franchise with automated reservation systems, regional distribution centers, and automatic failover—built to handle Black Friday crowds.

#### **3.3 Audio Data Flow**

Step-by-step journey of sound through the system:

**User speaks** → Microphone captures → WebAudio API processes → Converts to PCM16 format (digital audio) → Sends over WebSocket → Backend proxy receives → Forwards to Azure OpenAI Realtime API → AI generates response audio → Backend receives AI audio → Sends back over WebSocket → App converts to sound → Plays through speaker → **User hears Walter**

**Audio format**: PCM16, 24kHz sample rate, mono channel (CD-quality, single-channel audio)

---

### **Section 4: Mobile App Configuration**

#### **4.1 Environment Configuration File**

Shows the **only configuration file** the mobile app needs—and critically, it contains **zero secrets**:

```typescript
export const config = {
  API_BASE_URL: 'https://walter-api.yourcompany.com', // Public URL
  MSAL_CLIENT_ID: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx', // Public ID
  MSAL_AUTHORITY: 'https://login.microsoftonline.com/YOUR_TENANT_ID',
  MSAL_REDIRECT_URI: 'msauth.com.walter.voice://auth',
  MSAL_SCOPES: ['openid', 'profile', 'email', 'User.Read'],
  APP_VERSION: '1.0.0',
  VOICE_SAMPLE_RATE: 24000,
  VOICE_CHANNELS: 1,
  SESSION_TIMEOUT_MS: 1800000, // 30 minutes
};
```

**Critical note**: "The MSAL `CLIENT_ID` is a *public* identifier, not a secret. The mobile app uses the **public client** (PKCE) flow—no client secret is required on the device."

**Analogy**: The client ID is like your business address printed on your website—everyone can see it, but they still can't get into your office without proper credentials.

#### **4.2 What is NOT in the Mobile App**

A comprehensive table listing **9 types of secrets** that live exclusively on the backend server:

1. `AZURE_CLIENT_SECRET` - OAuth2 password
2. `JWT_SECRET` - Token signing/verification key
3. `AZURE_OPENAI_KEY` - AI API password
4. `AZURE_REALTIME_KEY` - Voice API password
5. `DATABASE_URL` - Database connection string
6. `REDIS_URL` - Session storage connection
7. `WEBPUBSUB_CONNECTION_STRING` - Voice infrastructure credentials
8. `SESSION_SECRET` - Cookie encryption key
9. `CLAIMSAI_SERVICE_PASSWORD` - External service auth

**All stored in**: Walter backend `.env` file only (server environment variables)

**Analogy**: The mobile app is like a hotel guest—they get a room keycard, but never get access to the master key system, safe combinations, server room passwords, or building blueprints.

#### **4.3 Secure Token Storage Code Example**

TypeScript code showing how tokens are stored using Capacitor Secure Storage:

```typescript
// Store tokens after login
await SecureStoragePlugin.set({
  key: 'walter_access_token',
  value: accessToken
});

await SecureStoragePlugin.set({
  key: 'walter_refresh_token',
  value: refreshToken
});

// Retrieve for API calls
const { value: token } = await SecureStoragePlugin.get({
  key: 'walter_access_token'
});
```

**Platform security:**
- **iOS**: Stored in iOS Keychain (hardware-encrypted, can require Face ID/Touch ID)
- **Android**: Stored in Android Keystore (hardware-backed encryption chip)
- **Cleared on logout**: Tokens deleted from device AND invalidated on server

**Analogy**: Like storing jewelry in a bank safe deposit box that requires your fingerprint to open—not hiding it under your mattress.

---

### **Section 5: API Interaction Patterns**

#### **5.1 Authenticated API Calls**

Code example showing how every request includes the access token:

```typescript
const response = await fetch(`${config.API_BASE_URL}/api/quotes`, {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${accessToken}`,
    'Content-Type': 'application/json',
  },
});

// Handle 401 — token expired
if (response.status === 401) {
  const newTokens = await refreshTokens();
  // Retry with new access token
}
```

**Logic**: Make request with token → If server returns "401 Unauthorized" (token expired) → Automatically refresh token → Retry request.

#### **5.2 Key API Endpoints Table**

Lists 11 main API endpoints the mobile app uses:

- `/api/auth/microsoft` - Initiate Microsoft login
- `/api/auth/microsoft/callback` - Handle login response
- `/api/auth/refresh` - Refresh expired token
- `/api/auth/logout` - Sign out and destroy session
- `/api/voice/negotiate` - Get voice connection URL
- `/api/voice/ws` - Direct WebSocket voice connection
- `/api/voice/session` (POST) - Start voice session
- `/api/voice/session` (DELETE) - End voice session
- `/api/quotes` - Get insurance quotes
- `/api/quotes/:id` - Get specific quote details
- `/api/chat` - Send chat message

#### **5.3 Error Handling Strategy (Smart API Client)**

Advanced code example showing automatic token refresh with fallback to re-login:

```typescript
class WalterAPIClient {
  async request(endpoint, options) {
    let response = await fetch(endpoint, { /* with token */ });
    
    // Token expired? Refresh and retry once
    if (response.status === 401) {
      await this.refreshAccessToken();
      response = await fetch(endpoint, { /* with new token */ });
    }
    
    // Still unauthorized? Something's wrong—force re-login
    if (response.status === 401) {
      await this.logout();
      this.navigateToLogin();
    }
    
    return response;
  }
}
```

**Logic**: Try request → Token expired? Get new token → Try again → Still fails? Log user out and return to login screen.

**Analogy**: Like trying to enter a building with your keycard—if it doesn't work, get a fresh card from security. If the fresh card also doesn't work, something's seriously wrong, so return to the front desk to re-verify your identity.

---

### **Section 6: Production Deployment Checklist**

#### **6.1 Backend Configuration Required**

Environment variables the Walter backend needs to support the mobile app:

```env
AZURE_MOBILE_REDIRECT_URI=msauth.com.walter.voice://auth
ALLOWED_ORIGINS=https://walter.yourcompany.com,capacitor://localhost,http://localhost
NODE_ENV=production
JWT_SECRET=<random-64-char-string>
```

#### **6.2 Azure AD App Registration Updates**

Step-by-step instructions for configuring Microsoft's system:

1. **Add platform**: Azure Portal → App Registration → Authentication
   - Add "Mobile and desktop applications" platform
   - Set redirect URI: `msauth.com.walter.voice://auth`
   - Enable "Allow public client flows" (required for mobile PKCE)

2. **API permissions**: Grant these:
   - `openid` (Sign in)
   - `profile` (Read basic profile)
   - `email` (Read email address)
   - `User.Read` (Read user profile from Microsoft Graph)

3. **Token configuration** (optional but recommended):
   - Add `email` optional claim to ID token
   - Add `preferred_username` optional claim to ID token

#### **6.3 Security Hardening Checklist**

A comprehensive **13-item security checklist** with checkboxes:

- [ ] HTTPS enforced on all backend endpoints
- [ ] WSS (WebSocket Secure) enforced for voice
- [ ] JWT_SECRET is 64+ characters of cryptographic randomness
- [ ] ALLOWED_ORIGINS strictly configured (no wildcards)
- [ ] Rate limiting on authentication endpoints (prevent brute force)
- [ ] Redis configured with authentication and TLS (`rediss://`)
- [ ] PostgreSQL configured with SSL (`?sslmode=require`)
- [ ] Azure API keys rotated on schedule
- [ ] iOS App Transport Security enabled (default)
- [ ] Android Network Security Config enforces TLS
- [ ] Certificate pinning considered (advanced security)
- [ ] Biometric authentication for app unlock (optional)
- [ ] Session invalidation on suspicious activity

**Analogy**: Like a pre-flight checklist for pilots—every item must be verified before the system is cleared for production takeoff.

---

### **Section 7: Technology Stack**

A table showing the technologies used in the mobile app:

- **Framework**: Capacitor + React/TypeScript (cross-platform iOS + Android)
- **Auth Library**: `@azure/msal-react-native` (Microsoft login with PKCE)
- **Token Storage**: `capacitor-secure-storage-plugin` (Keychain/Keystore)
- **Voice Capture**: WebAudio API + AudioWorklet (real-time audio)
- **WebSocket**: Native WebSocket API (voice streaming)
- **UI Framework**: Tailwind CSS / Custom... (text cuts off here)

---

## 3. How It Works

### **The Complete Security Model:**

**Traditional Insecure Approach:**
- Store database passwords, API keys, and credentials on every user's phone
- Risk: If anyone reverse-engineers the app or steals a phone, they get the keys to the entire kingdom

**Walter's Zero-Secrets Approach:**
1. **All secrets locked on servers** in environment files that only backend systems can read
2. **Mobile app gets temporary access tokens** (expire in 24 hours)
3. **Tokens stored in hardware-encrypted vaults** (iOS Keychain/Android Keystore)
4. **Microsoft handles authentication** so Walter never stores passwords
5. **If tokens are stolen**, they expire quickly and can be revoked server-side immediately

**Analogy**: It's like a maximum-security facility where guests get temporary day passes (tokens) stored in their biometric-protected wallets, but all the master keys, safe combinations, and server room passwords stay locked in the security chief's vault that's never connected to the internet.

---

### **The Login Journey (From Start to Finish):**

**Step 1-4: User Initiates Login**
1. Brett opens Walter app on his iPhone
2. Taps "Sign in with Microsoft"
3. App asks Walter's server where to send Brett
4. Server returns Microsoft's login page URL

**Step 5-8: Microsoft Authentication**
5. App opens Microsoft's login in a secure browser
6. Brett enters his work email (brett@company.com) and password
7. Microsoft may ask for security code (multi-factor authentication)
8. Microsoft verifies Brett's identity

**Step 9-11: Authorization Code Exchange**
9. Microsoft sends a secret authorization code back to Walter's server
10. Walter's server exchanges that code with Microsoft for official identity tokens
11. Microsoft returns ID token + access token confirming "Yes, this is Brett K from your company"

**Step 12-14: User Provisioning**
12. Walter checks its database: Does Brett exist?
    - **If yes**: Load Brett's profile
    - **If no**: Auto-create account with info from Microsoft
13. Walter creates two JWT tokens for Brett's phone:
    - **Access token** (24-hour pass)
    - **Refresh token** (7-day renewal voucher)
14. Walter sends both tokens + user profile to mobile app

**Step 15-16: Secure Storage**
15. App stores both tokens in iPhone Keychain (hardware-encrypted, Face ID protected)
16. User profile stored in temporary memory only (never written to disk)

**Brett is now logged in and can:**
- Talk to Walter via voice
- View insurance quotes
- Send chat messages
- All API requests include access token in header

**Token Maintenance:**
- **Every 24 hours**: App automatically uses refresh token to get new access token (seamless, no user action required)
- **After 7 days**: Refresh token expires, Brett must sign in again with Microsoft
- **On logout**: Both tokens deleted from iPhone AND invalidated on server

---

### **The Voice Conversation Flow:**

**Step 1-5: Establishing Connection**
1. Brett taps microphone button to talk to Walter
2. App sends request: `POST /api/voice/negotiate` with Bearer token
3. Server validates token, checks permissions
4. Server creates temporary WebSocket connection URL (scoped to this session, expires after use)
5. App receives WebSocket URL: `wss://pubsub.azure.com/...?token=xyz`

**Step 6-10: Audio Streaming (User Speaks)**
6. Brett starts speaking: "I need a marine cargo insurance quote"
7. iPhone microphone captures audio
8. WebAudio API processes raw audio data
9. Converts to PCM16 format (24,000 samples per second, mono channel)
10. Sends audio chunks over WebSocket every 200 milliseconds

**Step 11-15: Backend Processing**
11. Walter backend receives audio chunks
12. Forwards to Azure OpenAI Realtime API
13. AI transcribes speech to text: "I need a marine cargo insurance quote"
14. AI generates text response: "I can help you with that. Let me gather some details..."
15. AI converts text response to speech (audio)

**Step 16-20: Audio Response (User Hears Walter)**
16. Azure OpenAI sends response audio to Walter backend
17. Backend forwards to mobile app over WebSocket
18. App receives PCM16 audio chunks
19. WebAudio API converts to playable sound
20. Plays through iPhone speaker

**Step 21: Visual Display**
21. Conversation transcript appears on screen:
    - **User**: "I need a marine cargo insurance quote"
    - **Walter**: "I can help you with that. Let me gather some details..."

**This entire cycle happens in 500-1500ms** (half-second to 1.5 seconds from speaking to hearing response).

**Session Management:**
- One active voice session per user (can't have 5 simultaneous calls)
- Auto-expires after 30 minutes of inactivity
- Can be manually ended by tapping "End Call" button

---

## 4. Important Things to Know

### **Zero Secrets on Device is the Cornerstone:**

This is the **single most critical security principle** that governs the entire architecture. The document repeats this in multiple sections because it's that important.

**What "zero secrets" means:**
- NO passwords stored on phone
- NO API keys in app code
- NO database credentials
- NO Azure service keys
- NO JWT signing secrets
- NO encryption keys

**What IS on the phone:**
- Public configuration (API URLs, Microsoft Client ID—these are meant to be public like a business phone number)
- Temporary access tokens (expire in 24 hours)
- Refresh tokens (expire in 7 days, can be revoked server-side instantly)
- User profile (first name, last name, email, role—no sensitive financial or health data)

**Why this matters:**
- **If phone is stolen**: Thief gets tokens that expire in 24 hours max
- **If app is reverse-engineered**: Hacker finds public configuration values and expired tokens
- **If app is compromised**: No secrets to leak because none exist on device
- **Damage is minimal and time-limited**: Like losing a hotel keycard vs. losing the master key system

**Analogy**: It's like a spy movie where the field agent only carries today's code phrase (access token) and a voucher for getting this week's code phrases (refresh token), but the master codebook (secrets) stays locked in headquarters and is never transmitted to the field.

---

### **The MSAL Client ID is Public (Not a Secret):**

The document emphasizes this **multiple times** because developers often misunderstand it:

> "The MSAL `CLIENT_ID` is a *public* identifier, not a secret. The mobile app uses the **public client** (PKCE) flow—no client secret is required on the device. The client secret exists only on the Walter backend server."

**Why the client ID is public:**
- It's like a business phone number or mailing address—meant to be publicly known
- The mobile app uses **PKCE (Proof Key for Code Exchange)** security flow
- PKCE is designed specifically for mobile apps where secrets can't be stored
- The actual secret (client secret) lives only on Walter's backend server

**Analogy**: The client ID is like your company's address printed on business cards—everyone can see it, but they still can't walk into your office without proper security clearance.

---

### **Two-Token System Explained in Detail:**

**Access Token (24-hour lifespan):**
- **Purpose**: Proves who you are for every API request
- **Format**: JWT (JSON Web Token) with digital signature
- **Usage**: Included in HTTP header: `Authorization: Bearer {token}`
- **Contains**: User ID, session ID, expiration timestamp
- **Security**: Short lifespan = less risk if stolen
- **Analogy**: Like a day pass to an amusement park with your photo on it

**Refresh Token (7-day lifespan):**
- **Purpose**: Lets you get new access tokens without re-logging in
- **Format**: JWT with longer expiration
- **Usage**: Sent to `/api/auth/refresh` endpoint when access token expires
- **Contains**: User ID, session ID, token type marker, expiration timestamp
- **Security**: Both tokens rotate—when you get new ones, old ones stop working
- **Analogy**: Like a season pass voucher you can exchange for new day passes all week

**Why this two-token system?**
1. **Security**: If someone steals your access token, it expires in 24 hours
2. **Convenience**: You don't have to enter your Microsoft password every day
3. **Revocability**: Server can invalidate tokens immediately if suspicious activity detected
4. **Audit trail**: Server tracks every token refresh in Redis session database

**Token rotation (security feature):**
- When you refresh, you get NEW access token + NEW refresh token
- Old access token stops working immediately
- Old refresh token stops working immediately
- This prevents "replay attacks" where stolen tokens are reused

---

### **Production vs Development Voice Architecture:**

**Development Mode (Direct WebSocket):**
- Mobile app → Walter backend → Azure OpenAI
- **Pros**: Simple setup, easy debugging, good for small deployments
- **Cons**: Backend server handles all WebSocket connections (doesn't scale to thousands)
- **Use case**: Development, testing, small companies (< 100 concurrent users)

**Production Mode (Azure Web PubSub):**
- Mobile app → Web PubSub → Walter backend → Azure OpenAI
- **Pros**: Auto-scales to thousands, geographic distribution, automatic reconnection
- **Cons**: More complex setup, additional Azure service to configure
- **Use case**: Production deployments, enterprise scale (1000+ concurrent users)

**Why Web PubSub for production?**
- **Auto-scaling**: Handles 10,000 concurrent voice sessions without backend changes
- **Geographic distribution**: Users in Sydney connect to Sydney servers, New York users connect to New York servers (lower latency)
- **Connection resilience**: If network drops, Web PubSub automatically reconnects
- **Reduced backend load**: Walter's servers don't handle WebSocket connections directly

**Analogy**: 
- **Development mode**: Small restaurant where the owner cooks, serves, and manages reservations
- **Production mode**: Nationwide franchise with automated reservation systems, regional kitchens, and automatic failover when a location goes down

---

### **Microsoft SSO Eliminates Password Storage:**

**Why Microsoft Entra ID (formerly Azure AD)?**
1. **No password storage**: Walter never sees or stores user passwords—Microsoft handles that
2. **Enterprise security policies**: Companies can enforce password complexity, multi-factor auth, conditional access
3. **Automatic provisioning**: User logs in with work account → Walter auto-creates their profile
4. **Centralized deactivation**: Employee leaves company → Disable Microsoft account → Automatically locked out of Walter
5. **Leverages Microsoft's security**: Billion-dollar security infrastructure, AI-powered threat detection

**What happens during SSO:**
- User enters password into Microsoft's domain (login.microsoftonline.com)
- NOT into Walter's app
- Walter receives proof of identity, never the password itself

**Analogy**: Instead of each store having its own security checkpoint where you create a new account, everyone shows their government-issued driver's license that's already verified by a trusted authority (the DMV/Microsoft).

---

### **Session Isolation and Company Isolation:**

**Session Isolation:**
- Each login creates separate session in Redis database
- If Brett logs in on iPhone and iPad, those are TWO separate sessions
- Server tracks: user ID, device fingerprint, IP address, last activity timestamp
- Suspicious activity on one device doesn't affect other devices
- Can remotely invalidate specific sessions (e.g., "Sign out of all other devices")

**Company Isolation (Multi-Tenancy Security):**
- Database stores data for multiple insurance broker companies
- Server middleware automatically filters ALL queries by company ID
- Brett at Artemis Insurance can't see data from Beta Brokers
- This filtering happens at the middleware layer—developers can't accidentally bypass it
- Even if SQL injection vulnerability existed, attacker couldn't cross company boundaries

**Analogy**: 
- **Session isolation**: Like how your Netflix profile works on TV, phone, and laptop separately—you can sign out of one without affecting the others
- **Company isolation**: Like how bank tellers can log into the bank system but only access accounts they're authorized to service—they can't peek at the CEO's personal checking account even though it's in the same database

---

### **The Deployment Checklist is Mandatory:**

Section 6.3's **13-item security checklist** isn't a suggestion—these are **required** security controls for production:

**Critical items explained:**

1. **HTTPS/WSS enforcement**: Encrypts all traffic so eavesdroppers see gibberish
2. **JWT_SECRET strength**: 64+ character random string prevents attackers from forging fake tokens
3. **ALLOWED_ORIGINS**: Prevents malicious websites from making requests to Walter's API
4. **Rate limiting**: If someone tries to guess passwords 1000 times, blocks them after 5 failures
5. **Redis TLS**: Encrypts session data in transit to Redis database
6. **PostgreSQL SSL**: Encrypts database queries so snooping network admins can't see data
7. **API key rotation**: Regularly change Azure API keys so stolen keys expire
8. **iOS ATS / Android Network Security**: OS-level enforcement of HTTPS (can't be disabled by app)

**Missing even ONE item** could create an exploitable vulnerability.

**Analogy**: Like a pre-flight checklist for commercial pilots—you don't skip items because they seem tedious. Skipping "verify fuel levels" or "check hydraulic pressure" could crash the plane. These security checks prevent the digital equivalent of crashing.

---

### **Platform-Specific Security (iOS vs Android):**

**iOS Security:**
- **Keychain**: Hardware-encrypted storage in secure enclave (dedicated chip)
- **Biometric protection**: Can require Face ID or Touch ID to access tokens
- **App Transport Security (ATS)**: iOS enforces HTTPS by default—apps can't make HTTP requests
- **Secure enclave**: Encryption keys never leave the chip, even Apple can't extract them

**Android Security:**
- **Keystore**: Hardware-backed encryption using ARM TrustZone or Titan chip (Pixel)
- **Biometric protection**: Can require fingerprint or face unlock to access tokens
- **Network Security Config**: Enforces TLS 1.2+ at OS level
- **StrongBox**: Google Pixel phones have dedicated security chip like iPhone's secure enclave

**Both platforms:**
- Hardware-level encryption (not just software that could be bypassed)
- Tokens encrypted at rest (stored encrypted on disk)
- Tokens encrypted in transit (HTTPS/WSS to server)
- OS enforces security policies (app can't weaken them)

**Analogy**: Like the difference between hiding valuables in a locked suitcase (software encryption) vs. storing them in a bank vault with biometric access (hardware encryption). Both are secure, but hardware encryption is Fort Knox.

---

### **Error Handling is Intelligent:**

The `WalterAPIClient` class shows **smart automatic recovery**:

**Scenario 1: Token Expired**
- Make API request
- Server returns 401 Unauthorized
- Client automatically uses refresh token to get new access token
- Retry original request with new token
- User never knows it happened (seamless)

**Scenario 2: Refresh Token Also Expired**
- Make API request
- Server returns 401 Unauthorized
- Client tries to refresh → Server returns 401 again (refresh token expired)
- Client logs user out, clears tokens, navigates to login screen
- User sees friendly message: "Your session expired. Please sign in again."

**Scenario 3: Network Error**
- Request fails due to no internet
- Client shows error: "No internet connection. Please check your network."
- Doesn't log user out (tokens still valid)
- User can retry when connection restored

**Analogy**: Like a car with automatic collision avoidance—it tries to correct course automatically, but if that fails, it safely stops the car and alerts the driver rather than crashing.

---

### **Audio Quality and Performance:**

**Audio specifications:**
- **Format**: PCM16 (Pulse Code Modulation, 16-bit)
- **Sample rate**: 24,000 Hz (24,000 measurements per second)
- **Channels**: Mono (single channel, not stereo)
- **Bit depth**: 16-bit signed integer
- **Data rate**: ~48 KB/s (kilobytes per second)
- **Chunk size**: 200 milliseconds (4,800 samples per chunk)

**What this means:**
- **CD quality** (slightly below CD which is 44.1 kHz, but optimized for voice)
- **5-minute call**: ~14 MB of data transfer
- **Low latency**: 200ms chunks = near-real-time (minimal delay)
- **Efficient**: Mono channel uses half the bandwidth of stereo

**Analogy**: Like the difference between studio recording quality (overkill for phone calls) and Zoom call quality (optimized for voice clarity at reasonable bandwidth).

---

## In Summary

This document is a **complete, production-ready security blueprint** for building an enterprise-grade mobile voice AI app where:

✅ **Zero secrets stored on phones** (everything sensitive stays server-side)  
✅ **Microsoft handles authentication** (no password storage in Walter)  
✅ **Temporary tokens** provide time-limited access (24-hour + 7-day)  
✅ **Hardware-encrypted storage** protects tokens (Keychain/Keystore)  
✅ **Scalable voice architecture** supports thousands of users (Web PubSub)  
✅ **Comprehensive security checklist** ensures production readiness  
✅ **Intelligent error handling** with automatic recovery  
✅ **Multi-tenant isolation** prevents data leakage between companies  

**The document provides everything a developer needs:**
- Complete code examples (copy-paste ready)
- Architecture diagrams (visual flowcharts)
- Configuration files (exact settings needed)
- Deployment checklists (step-by-step verification)
- Security hardening guide (13-point mandatory checklist)
- Technology stack details (specific libraries and versions)

**The security model ensures:**
Even if phones are stolen, apps are reverse-engineered, tokens are intercepted, or databases are breached, the damage is **minimal, time-limited, and traceable**—like losing a hotel keycard that expires tomorrow instead of losing the master key system to the entire hotel chain's global properties.

This is **enterprise-grade security architecture** suitable for regulated industries (insurance, healthcare, finance) where data breaches can cost millions in fines and reputation damage.