# Explanation of `.claude/commands/revise-claude-md.md`

## What This File Does

This document is an instruction manual for a command called `/revise-claude-md` that helps the AI assistant learn from its work and update a special memory file called `CLAUDE.md`. Think of it like a teacher asking students to write down the important lessons learned after completing a project, so future students can benefit from those insights. After the AI finishes working on a task, this command guides it to reflect on what was helpful, what was tricky, and what information would have made the work easier - then it writes those learnings into a memory file that will be automatically loaded in future sessions. This creates a continuous improvement cycle where each session makes the AI slightly more effective at working with your specific codebase.

## Key Components

**Introduction and Purpose**: The opening line explains the core mission - "Review this session for learnings about working with Claude Code in this codebase. Update CLAUDE.md with context that would help future Claude sessions be more effective." It also specifies which tools are allowed (Read, Edit, Glob - tools for finding and modifying files).

**Step 1 - Reflect**: This section prompts the AI to think back over the work session and identify missing context that would have been helpful. It provides five specific categories to consider:
- **Bash commands**: Any terminal commands that were used or discovered (like how to run tests, start servers, or check file status)
- **Code style patterns**: Conventions followed in the codebase (like naming conventions, formatting rules, or organizational patterns)
- **Testing approaches**: Methods that worked well for verifying code works correctly
- **Environment/configuration quirks**: Unusual setup requirements or special settings needed
- **Warnings or gotchas**: Tricky issues encountered that future sessions should be aware of

**Step 2 - Find CLAUDE.md Files**: Provides a specific terminal command to search for `CLAUDE.md` files in the project, then explains where different types of information belong:
- **CLAUDE.md**: Team-shared knowledge that gets checked into version control (saved in git) so everyone benefits
- **.claude.local.md**: Personal notes specific to your local setup that don't get shared (gitignored)

**Step 3 - Draft Additions**: Sets formatting guidelines for what to write. Critically, it emphasizes **"Keep it concise - one line per concept"** because CLAUDE.md gets loaded into the AI's prompt, so brevity matters for efficiency. It provides a format template: `<command or pattern>` - `<brief description>`. It also lists what NOT to include: verbose explanations, obvious information, or one-off fixes unlikely to happen again.

**Step 4 - Show Proposed Changes**: Instructs the AI to present each proposed addition in a structured format showing where it will be added, why it's valuable, and what the actual addition looks like (using a "diff" format that shows new lines with a `+` symbol).

**Step 5 - Apply with Approval**: Requires the AI to ask for user permission before making any changes. Files only get edited if the user approves the proposed additions. This is a safety checkpoint ensuring the AI doesn't automatically modify important memory files without human oversight.

## How It Works

**The Reflection Process**: When you run `/revise-claude-md` after completing work, the AI mentally reviews what just happened in the session. It asks itself questions like: "Did I struggle to find how to run tests? That command should be documented." or "Did I discover the codebase uses a specific naming convention? That pattern should be recorded." or "Did I hit a weird configuration issue? That gotcha should be noted as a warning."

**The Information Categorization**: The AI then sorts its learnings into two buckets: team-shared knowledge (goes in CLAUDE.md and gets saved to git) versus personal/local knowledge (goes in .claude.local.md and stays on your computer only). For example, "This project uses pytest for testing" is team-shared knowledge, while "My local Redis runs on port 6380 instead of the default 6379" is personal configuration.

**The Drafting Phase**: For each learning, the AI writes a very concise one-liner following the specified format. For example: "`pytest tests/` - Run all unit tests" or "`use camelCase for function names` - Project style convention" or "`Redis must be running on port 6379` - Start with `docker-compose up redis`". The emphasis on brevity is important because CLAUDE.md gets loaded into every future session's prompt, and long documents waste processing capacity.

**The Proposal and Approval Flow**: Instead of silently editing files, the AI presents its proposed additions in a clear format showing what will be added and why. You review each proposal and decide whether to approve it. This human-in-the-loop approach prevents the AI from cluttering the memory file with unhelpful or incorrect information. Only approved changes actually get written to the files.

**The Cumulative Learning Effect**: Over time, as you work on different parts of the codebase and run `/revise-claude-md` after sessions, the CLAUDE.md file gradually accumulates useful context. Future AI sessions automatically load this file, meaning they start with all the accumulated knowledge from previous sessions - common commands, style patterns, testing approaches, configuration quirks, and gotchas. This makes each subsequent session progressively more efficient.

## Important Things to Know

**This Creates a Persistent Memory System**: Unlike a single conversation where the AI forgets everything afterwards, this command enables persistent memory across sessions. Think of it like writing tips in the margins of a cookbook - each time you cook a recipe, you learn something and write it down, so the next time you (or someone else) uses that cookbook, you benefit from all the accumulated wisdom.

**It Only Runs When You Explicitly Call It**: This command doesn't run automatically - you need to invoke it (typically by typing `/revise-claude-md` in the chat). It's usually used at the end of a work session when you've completed a task and want to capture learnings before they're forgotten.

**Brevity is Critical**: The document emphasizes multiple times to "keep it concise" and limit to "one line per concept." This isn't just stylistic preference - it's a technical requirement. CLAUDE.md gets loaded into the AI's prompt in every future session, and AI prompts have limited capacity. Verbose documentation wastes that capacity and makes sessions less effective. Every word should earn its place.

**You Control What Gets Saved**: The Step 5 approval requirement means you have final say over what goes into your memory files. If the AI proposes something that seems wrong, unclear, or not useful, you can reject it. This prevents the memory file from accumulating cruft or incorrect information that would mislead future sessions.

**Two Types of Memory Files**: The distinction between `CLAUDE.md` (shared) and `.claude.local.md` (personal) is important. Shared knowledge that benefits the whole team goes in CLAUDE.md and gets checked into git. Personal configuration specific to your local setup goes in .claude.local.md and stays private. For example, "Use `npm test` to run tests" is shared knowledge, while "My local database password is stored in .env.local" is personal configuration.

**It's About Future Effectiveness, Not Documentation**: This isn't trying to create comprehensive project documentation - that's what README files and wikis are for. Instead, it's capturing the specific context that makes the AI work more effectively in this particular codebase. Think of it as training notes for a new employee: not a complete manual, but the key tips that help them be productive quickly.

**The Format is Structured for Clarity**: The required format `<command or pattern>` - `<brief description>` provides consistency that makes the memory file easy to scan and understand. For example: "`python relay.py server -p 7786` - Start Relay server on port 7786" or "`Functions use snake_case` - Follow Python naming conventions". This structure is optimized for quick comprehension by both humans and AI.

**It Filters Out Noise**: The "Avoid" list in Step 3 is crucial - it prevents the memory file from filling up with obvious information ("Python uses indentation"), verbose explanations (long paragraphs about why something works), or one-off fixes that won't recur ("Fixed a typo on line 47"). Only recurring, useful, non-obvious insights should make the cut.

**This is a Learning Loop**: The entire concept creates a virtuous cycle: work on project → encounter learnings → document them → future sessions benefit → become more effective → discover new learnings → document them → and so on. Over time, the AI becomes increasingly knowledgeable about your specific codebase's quirks, conventions, and best practices.

**Manual Review Prevents Pollution**: Because the AI must show proposals and get approval before editing, there's a quality control gate that prevents the memory file from degrading over time. Without this, the file could gradually fill with outdated, incorrect, or redundant information. The approval step keeps the memory file high-quality and trustworthy.